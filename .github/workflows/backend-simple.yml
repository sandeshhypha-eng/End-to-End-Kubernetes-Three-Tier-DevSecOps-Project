name: Backend - Simple CI

on:
  push:
    paths:
      - 'Application-Code/backend/**'
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Optional image tag to push (defaults to commit sha)'
        required: false
        default: ''

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          cd Application-Code/backend
          # Prefer clean install from lockfile for reproducible builds
          if [ -f package-lock.json ] || [ -f npm-shrinkwrap.json ]; then
            echo "Lockfile found, running 'npm ci'"
            npm ci
          else
            echo "No lockfile found, running 'npm install' and generating package-lock.json if needed"
            npm install
          fi

      - name: Run tests (if present)
        run: |
          cd Application-Code/backend
          if [ -f package.json ] && npm test --silent; then echo "tests ran"; else echo "no tests or tests failed"; fi

  docker:
    name: Build, scan and push image
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4

      - name: Set IMAGE_TAG
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "IMAGE_TAG=${{ github.event.inputs.image_tag }}" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
          fi

      - name: Build Docker image
        run: |
          docker build -t backend:${{ env.IMAGE_TAG }} Application-Code/backend

      - name: Scan image with Trivy
        run: |
          IMAGE=backend:${{ env.IMAGE_TAG }}
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --severity HIGH,CRITICAL --exit-code 1 "$IMAGE" || true

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: priya720
          password: Sandy@100!

      - name: Tag and push image to Docker Hub
        run: |
          IMAGE=backend:${{ env.IMAGE_TAG }}
          REPO=priya720/backend
          docker tag "$IMAGE" "$REPO:${{ env.IMAGE_TAG }}"
          docker tag "$IMAGE" "$REPO:latest"
          docker push "$REPO:${{ env.IMAGE_TAG }}"
          docker push "$REPO:latest"

  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: docker
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-south-1

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.27.3'

      - name: Install Helm
        uses: azure/setup-helm@v1
        with:
          version: 'v3.12.0'

      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name dev --region ap-south-1

      - name: Set kubectl context namespace
        run: |
          kubectl config set-context --current --namespace=three-tier

      - name: Deploy backend (Helm chart if present, otherwise kubectl)
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          else
            IMAGE_TAG="${{ github.sha }}"
          fi
          IMAGE_REPO="${{ secrets.DOCKERHUB_USERNAME }}/backend"
          CHART_DIR=./charts/backend
          # ONLY deploy manifests from this exact directory
          MANIFEST_DIR="Kubernetes-Manifests-file/Backend"

          if [ -d "$CHART_DIR" ]; then
            echo "Found Helm chart at $CHART_DIR — deploying with Helm"
            helm upgrade --install backend "$CHART_DIR" \
              --namespace three-tier --create-namespace \
              --set image.repository=${IMAGE_REPO} \
              --set image.tag=${IMAGE_TAG} \
              --wait --timeout 3m
          else
            echo "Helm chart not found at $CHART_DIR — deploying manifests from $MANIFEST_DIR"
            if [ ! -d "$MANIFEST_DIR" ]; then
              echo "Expected manifest directory '$MANIFEST_DIR' not found. Failing the job so you can add manifests to that path."
              exit 1
            fi

            echo "Repo contents:"; ls -la "$MANIFEST_DIR" || true
            kubectl -n three-tier apply -R -f "$MANIFEST_DIR"
            # Wait for the backend deployment named 'api' (as in the repo) to roll out.
            kubectl -n three-tier rollout status deployment/api --timeout=3m || (
              echo "Backend rollout failed or timed out; fetching events" &&
              kubectl -n three-tier get pods -l role=api -o wide &&
              kubectl -n three-tier describe deployment api &&
              kubectl -n three-tier get events --sort-by='.lastTimestamp' &&
              exit 1
            )
          fi

# Notes:
# - Required secrets if using Docker Hub for push: DOCKERHUB_USERNAME, DOCKERHUB_PASSWORD
# - Optional Sonar: SONAR_TOKEN and SONAR_HOST_URL
# - This is a simple pipeline modeled after your example. Tell me if you want ECR instead of Docker Hub or to deploy to Kubernetes after push.